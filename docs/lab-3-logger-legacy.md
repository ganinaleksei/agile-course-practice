# Лабораторная работа #3: Logger

## Цели

  1. На практике освоить _принцип инверсии зависимостей_ (DIP) на примере
     реализации функции логирования.
  1. Продолжить формирование архитектуры в DDD-стиле, путем введения
     инфраструктурного слоя.
  1. Усвоить разницу между модульными и инфраструктурными тестами на примере
     "реального" логгера и класса `ViewModel`. Здесь же будет небольшое
     упражнение на LSP в виде того, что все тесты `ViewModel` должны проходить
     как с "фиктивным", так и с "реальным" логгером.

## Задачи

  1. Добавить во `ViewModel` функциональность логирования всех действий
     пользователя.
     - Для этого следует определить интерфейс `ILogger` и предоставить некоторую
       "фиктивную" его реализацию для целей тестирования, не использующую
       файловый ввод-вывод.
     - Функциональность логирования как и ранее должна быть реализована по TDD и
       обеспечивать полное покрытие тестами. Тестирование должно проводиться при
       помощи фиктивной реализации логгера.
  1. Добавить в проект новую сборку под названием `Infrastructure`. В ней
     необходимо:
     - Реализовать по TDD "реальный" класс логгера, работающего с текстовыми
       файлами. Это будут первые инфраструктурные тесты в вашем приложении.
     - Также добавить запуск всех тестов на `ViewModel`, но передавать классу
       "реальный" логгер вместо "фиктивного". Это будут вторые инфраструктурные
       тесты.
  1. Добавить возможность отображения лога действий пользователя на графическую
     форму из сборки `View`. Лог должен содержать метки времени, в которые
     происходили действия пользователя.

## Инструкции

### Предварительная работа

Первым делом нужно обновить состоиние репозитория, а также ознакомиться с
проектом-примером, который в этот раз находится в директории `kirill-kornyakov-lab3-legacy`.

   1. Если проект открыт у вас в IDEA, нужно его закрыть: _File > Close Project_.
   1. После этого предлагается удалить все сгенерированные файлы, в том числе
      файлы проектов и билд-директории:
```
$ cd <agile-course-practice>/code
$ gradle clean cleanIdea cleanIdeaWorkspace cleanEclipse
```
   1. Теперь стоит скачать обновления с GitHub, после чего создать новую ветку
      для новой лабораторной работы и проверить что проект успешно собирается.
```
$ git checkout master
$ git fetch upstream
$ git rebase upstream/master
$ git checkout -b lab3-ANYTHING-BUT-COOL
# Check that you're in <agile-course-practice>
$ gradle check
```
      Все тесты должны пройти успешно, в том числе в вашем проекте и
      проекте-примере. Если на этом этапе будут какие-то проблемы, проверьте
      что ваша ветка `master` не содержит ненужных измененений. Она должна
      быть чистой копией состояния в `upstream/master`.
   1. Теперь как и в прошлой лабораторной можно сгенерировать проект для IDEA,
      и открыть его (именно открыть, а не импортировать). Для этого повторяем те
      же шаги, что были описаны в прошлой лабораторной: генерация проекта при
      помощи команды `gradle idea`, затем открытие его в IDEA командой
      _File > Open..._. Должно появиться полное дерево проектов, и среди них
      `kirill-kornyakov-lab3-legacy` с новой сборкой `Infrastructure`.
   1. Далее стоит запустить все тесты из проекта
      `kirill-kornyakov-Infrastructure-lab3-legacy`, после чего можно запустить
      графическое приложение (проект `kirill-kornyakov-View`) и ознакомиться с
      логикой логирования.

На этом подготовительная работа заканчивается. Если на каком-то этапе возникли
проблемы с генерацией и открытием проекта, можно попробовать перегенерировать
все заново. Тогда нужно закрыть IDEA и выполнить следующие команды в консоли
(команды даются для UNIX-based систем):

```bash
        # Check that you're in <agile-course-practice>
        $ rm code.i*
        $ find . -name '*.iml' | xargs rm
        $ find . -name 'build' | xargs rm -rf
```

После этого можно снова сгенерировать проект и открыть его в IDEA.

### Реализация логики логирования во `ViewModel`

Как обычно, весь код будет создаваться по практике TDD.

  1. Первым делом нужно спроектировать интерфейс логгера. Минимально он должен
     позволять добавлять сообщения в лог, а также возвращать полное содержимое
     лога.
  1. Далее нужно написать первый тест на `ViewModel`, проверяющий, что тот может
     работать с логгером. Скорее всего это будет тест на конструктор, который
     принимает логгер в качестве входного аргумента. Чтобы заставить этот тест
     пройти, нужно будет изменить конструктор, а также реализовать "фиктивный"
     логгер, который будет доступен только в тестах.
  1. После этого идет основная разработка. Пишутся новые тесты, проверяющие, что
     `ViewModel` корректно ведет логирование действий пользователя. При этом
     используется "фиктивный" логгер. Скорее всего потребуется пересмотреть
     дизайн класса `ViewModel` чтобы позволить это. Так, в проекте-примере все
     члены стали приватными, и появились методы-аксессоры, чтобы обеспечить
     корректное логирование и удобное тестирование.

### Создание сборки `Insfrastructure` и "реального" логгера

На этом этапе `ViewModel` уже должна вести логирование соответствующим образом.
Однако чтобы графическое приложение вело реальный текстовый лог, нам потребуется
"реальный" логгер. Здесь мы создадим простейший текстовый логгер, реализующий
интерфейс логгера. Этот логгер также должен разрабатываться по TDD, но в данном
случае тесты будут инфраструктурные, поскольку они будут использовать реальный
файловый ввод-вывод.

  1. Первым делом создаем папку `Infrastructure` и в ней директории для
     исходников `src/main` и `src/test`. Далее пишем `build.gradle` файл и
     регистрируем его в общем `settings.gradle`, подобно тому как это делалось
     в прошлой лабораторной работе. Нужно будет снова запустить команду
     `gradle idea` для генерации проекта. Ниже пример файла `build.gradle`:
```
dependencies {
    compile project(':kirill-kornyakov-ViewModel')
    testCompile project(':kirill-kornyakov-ViewModel').sourceSets.test.output
}

sourceSets {
    main.java.srcDir 'src/main'
    test.java.srcDir 'src/test'
}
```
  1. Когда окружение готово, можно приступать к реализации класса-логгера.
     Собственно начинаем с простейшего теста, проверяющего, что мы умеем
     создавать такой класс. Далее создаем этот класс и указываем, что он
     реализует интерфейс логгера из сборки `ViewModel`. После чего реализуем
     все необходимые методы этого класса, работая согласно практике TDD.
  1. Далее полезно проделать следующий трюк. Класс `ViewModel` разрабатывался и
     тестировался в связке с "фиктивным" логгером, в том время как в реальности
     будет использоваться с "реальным". В то же время нам практически ничего не
     стоит тестировать его еще и с "реальным" логгером. Однако мы должны
     понимать, что это уже инфраструктурные тесты, и лучше поместить их в сборку
     `Infrastructure`. Ниже приведен пример, как можно запустить все тесты
     `ViewModel`, но уже с "реальным" логгером:
```java
public class ViewModelWithTxtLoggerTests extends ViewModelTests {
    @Override
    public void setUp() {
        TxtLogger realLogger = new TxtLogger("./ViewModelWithTxtLoggerTests.log");
        viewModel = new ViewModel(realLogger);
    }
}
```
    Все, что нужно было сделать - это отнаследовать одну тестовую сборку от
    другой, и переопределить метод `setUp`.

### Привязка логики логирования к графической форме

Остался самый последний этап — это привязать реализованную логику логирования
к графической форме.

  1. Первым делом стоит добавить зависимость сборки `View` от `Insfrastructure`.
     Для этого в `build.gradle` файл `View` вписываем следующую стоку в секцию
     зависимостей:
```
    compile project(':kirill-kornyakov-Infrastructure')
```
  1. Далее нужно добавить графические компоненты, которые будут отображать
     содержимое лога. В проекте-примере был добавлен компонент типа
     `JScrollPane` и на нем размещен `JList`, в результате чего список получил
     полосу прокрутки.
  1. Последним шагом осталось связать `View` и логику логирования во
     `ViewModel`. Для этого нужно будет передать "реальный" логгер в конструктор
     `ViewModel` и расширить имеющийся биндинг еще и на содержимое лога.

По большому счету на этом все, однако вам предлагается протестировать
корректность логирования руками и убедиться, что все происходит как
задумывалось. Наверняка что-то покажется не вполе логичным или даже корректным.
В таком случае может потребоваться переделка логики `ViewModel`, и даже
существенный ее рефакторинг. Однако всякий раз стоит начинать с теста, будь то
исправление ошибкм (тогда нужно написать "красный" тест, ее показывающий), или
реализация новой функциональности.

## Заключение

Теперь самое время пройтись по проекту целиком и посмотреть, все ли грамотно и
красиво сделано. Также можно пройтись по спику проверок, приведенному ниже.
Если все будет хорошо, можно будет делать пулл-реквест. Просьба использовать
имя согласно соглашениям: _"Корняков - Лабораторная работа #3"_.

## Контрольный список

Ниже приведен список проверок, по которому проверяется лабораторная работа.
Предлагается также использовать его для самопроверки.

1. Проект проходит построение на Travis. При этом должны запускаться 4 набора
   тестов: на вашу `Model`, на `ViewModel` (с "фиктивным логгером"), на
   "реальный логгер", а также на `ViewModel` c "реальным" логгером.
1. `ViewModel` тестируется с фиктивным логгером. Набор тестов должен покрывать
   все случаи использования логгера (все действия пользователя).
1. Реальный логгер находится в сборке `Infrastructure`. Там же располагаются
   инфраструктурные тесты на него и `ViewModel`.
1. `View` передает `ViewModel` "реальный" логгер. В остальном она остается такой
   же простой как и в предыдущей лабораторной.
1. Как обычно проверяются следующие моменты:
   - Весь код высокого качества, с понятыми именами и отсутствием дублирования
   - Все сценарии покрыты тестами (см. также code coverage), нет кода, который
     можно удалить, и ни один тест при этом не сломается
   - Тесты следуют практике AAA, соответствуют критериям хорошего модульного
     теста

<!-- LINKS -->
